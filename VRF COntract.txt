// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// üß† Chainlink VRF references 
// import "@chainlink/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol";
// import "@chainlink/c// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// üß† Chainlink VRF references 
// import "@chainlink/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol";
// import "@chainlink/contracts/src/v0.8/vrf/interfaces/VRFCoordinatorV2Interface.sol";

contract DynastyJackpot {
    address public owner;

    // VRF variables 
    address public vrfCoordinator;
    uint64 public subscriptionId;
    bytes32 public keyHash;
    uint32 public callbackGasLimit = 2500000;
    uint16 public requestConfirmations = 3;

    uint256 public taxPool; // üßß Accumulated tax (in wei)
    uint256 private randNonce;

    struct Tier {
        string name;
        uint256 minPrize;
        uint256 maxPrize;
        address[] holders;
    }

    mapping(uint256 => Tier) public tiers;

    struct Winner {
        address wallet;
        uint256 tier;
        uint256 prizeAmount;
        uint256 timestamp;
        string tierName;
    }

    Winner[] public winners;

    struct RequestData {
        uint256 tier;
    }

    mapping(uint256 => RequestData) public requests;

    event WinnerPicked(address indexed wallet, string tierName, uint256 prize, uint256 time);
    event RandomnessRequested(uint256 indexed requestId, uint256 tier);
    event HoldersUpdated(uint256 tier, uint256 count);
    event TaxAdded(uint256 amount, uint256 total);

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    // üß† Constructor ( VRF args)
    constructor(
        address _vrfCoordinator,
        bytes32 _keyHash,
        uint64 _subscriptionId
    ) {
        owner = msg.sender;
        vrfCoordinator = _vrfCoordinator;
        keyHash = _keyHash;
        subscriptionId = _subscriptionId;

        // Initialize tier ranges
        tiers[1].name = "Mini Makis";
        tiers[1].minPrize = 0.01 ether;
        tiers[1].maxPrize = 0.1 ether;

        tiers[2].name = "Lucky Rollers";
        tiers[2].minPrize = 0.1 ether;
        tiers[2].maxPrize = 0.3 ether;

        tiers[3].name = "High Emperors";
        tiers[3].minPrize = 0.5 ether;
        tiers[3].maxPrize = 1 ether;

        tiers[4].name = "Mega Jackpot Pool";
        tiers[4].minPrize = 0;
        tiers[4].maxPrize = 0;
    }

    // üí∞ Receive BNB (adds to tax pool)
    receive() external payable {
        taxPool += msg.value;
        emit TaxAdded(msg.value, taxPool);
    }

    function addTax() external payable onlyOwner {
        taxPool += msg.value;
        emit TaxAdded(msg.value, taxPool);
    }

    // ====== Dynamic Holder Update ======
    function updateTierHolders(uint256 tier, address[] calldata newHolders) external onlyOwner {
        delete tiers[tier].holders;
        for (uint256 i = 0; i < newHolders.length; i++) {
            tiers[tier].holders.push(newHolders[i]);
        }
        emit HoldersUpdated(tier, newHolders.length);
    }

    // ====== Mock VRF Request ======
    function requestRandomWinner(uint256 tier) external onlyOwner returns (uint256 requestId) {
        require(tiers[tier].holders.length > 0, "No holders in tier");

        // Fake VRF request ID
        requestId = ++randNonce;
        requests[requestId] = RequestData({tier: tier});
        emit RandomnessRequested(requestId, tier);

        // Immediately resolve pseudo-randomly
        _fulfillRandomWords(requestId);
    }

    // ====== fulfillRandomWords ======
    function _fulfillRandomWords(uint256 requestId) internal {
        uint256 tier = requests[requestId].tier;
        Tier storage t = tiers[tier];
        require(t.holders.length > 0, "No holders in tier");

        // ‚ö†Ô∏è Pseudo-random only
        uint256 rand = uint256(
            keccak256(abi.encodePacked(block.timestamp, msg.sender, randNonce))
        );

        uint256 randomIndex = rand % t.holders.length;
        address winner = t.holders[randomIndex];

        uint256 prize;
        if (tier == 4) {
            prize = taxPool;
            taxPool = 0;
        } else {
            uint256 range = t.maxPrize - t.minPrize;
            prize = t.minPrize + (rand % range);
        }

        winners.push(
            Winner({
                wallet: winner,
                tier: tier,
                prizeAmount: prize,
                timestamp: block.timestamp,
                tierName: t.name
            })
        );

        emit WinnerPicked(winner, t.name, prize, block.timestamp);
    }

    // ====== View ======
    function getAllWinners() external view returns (Winner[] memory) {
        return winners;
    }

    function getTierInfo(
        uint256 tier
    )
        external
        view
        returns (
            string memory name,
            uint256 minPrize,
            uint256 maxPrize,
            uint256 count
        )
    {
        Tier storage t = tiers[tier];
        return (t.name, t.minPrize, t.maxPrize, t.holders.length);
    }
}

